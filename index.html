<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Effect Editor - Christmas Card 2021</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">

    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">

    <style>
        #canvas {
            display: block;
            margin: 16px auto;
            border: solid 1px lightgray;
        }

        #effect-controls, #frame-controls{
            text-align: center;
            margin: 16px auto;
        }
    </style>
</head>
<body>

<div id="effect-controls">
    <div class="d-inline-block mx-1">
        <div class="input-group">
            <span class="input-group-text">Import</span>
            <label class="btn btn-outline-success" for="import-json">JSON</label>
        </div>
        <input type="file" class="d-none" id="import-json" accept="application/json" />
    </div>
    <div class="d-inline-block mx-1">
        <div class="input-group">
            <span class="input-group-text">Export</span>
            <button class="btn btn-outline-success" id="export-json">JSON</button>
        </div>
    </div>
</div>

<canvas id="canvas"></canvas>

<div id="frame-controls">
    <div class="d-inline-block mx-1" style="width: 200px;">
        <div class="input-group">
            <label class="input-group-text" for="duration">Duration</label>
            <input type="text" class="form-control" id="duration" style="text-align: right;">
            <span class="input-group-text">ms</span>
        </div>
    </div>
    <div class="d-inline-block mx-1">
        <div class="input-group">
            <span class="input-group-text">Move</span>
            <button class="btn btn-outline-primary bi bi-caret-left" id="move-left"></button>
            <button class="btn btn-outline-primary bi bi-caret-right" id="move-right"></button>
        </div>
    </div>
    <div class="d-inline-block mx-1">
        <div class="input-group">
            <span class="input-group-text">All</span>
            <button class="btn btn-outline-primary bi bi-circle" id="select-none"></button>
            <button class="btn btn-outline-primary bi bi-circle-half" id="toggle-all"></button>
            <button class="btn btn-outline-primary bi bi-circle-fill" id="select-all"></button>
        </div>
    </div>
    <div class="d-inline-block mx-1">
        <div class="input-group">
            <button class="btn btn-outline-primary bi bi-files" id="frame-copy"></button>
        </div>
    </div>
    <div class="d-inline-block mx-1">
        <div class="input-group">
            <button class="btn btn-outline-danger bi bi-trash" id="frame-delete"></button>
        </div>
    </div>
</div>

<nav id="frame-nav">
    <ul class="pagination justify-content-center">
        <li class="page-item play"><button class="page-link bi bi-play"></button></li>
        <li class="page-item add"><button class="page-link bi bi-plus"></button></li>
    </ul>
</nav>

<script type="application/javascript">

    class Point {

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        add(other) {
            return new Point(this.x + other.x, this.y + other.y);
        }

        sub(other) {
            return new Point(this.x - other.x, this.y - other.y);
        }

        distSquared(other) {
            return Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2);
        }

        insideRect(point1, point2) {
            const tl = new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
            const br = new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
            return tl.x <= this.x && tl.y <= this.y && br.x >= this.x && br.y >= this.y;
        }

    }

    class Frame {

        constructor() {
            this._leds = [];
            for (let i = 0; i < 54; i++) {
                this._leds.push(false);
            }
            this.duration = 200;
        }

        toggle(index) {
            this._leds[index - 1] = !this._leds[index - 1]
        }

        toggleAll() {
            this._leds = this._leds.map(l => !l);
        }

        clearAll() {
            this._leds.fill(false);
        }

        setAll() {
            this._leds.fill(true);
        }

        isOn(index) {
            return this._leds[index - 1];
        }

        clone() {
            const clone = new Frame();
            clone._leds = [...this._leds];
            clone.duration = this.duration;
            return clone;
        }

    }

    const canvas = document.querySelector("#canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = 800;
    canvas.height = 800;
    canvas.style.width = "400px";
    canvas.style.height = "400px";
    ctx.scale(8, 8);
    ctx.lineWidth = 0.1;
    ctx.font = "2px Arial";
    ctx.fillStyle = "gray";

    const ledPositions = {};
    let mouseStart = null, mouseEnd = null;
    let currentFrame = new Frame();
    let frames = [currentFrame];

    function radToDeg(a) {
        return a / Math.PI * 180;
    }

    function anglePoints(a, b) {
        return Math.atan((a.y - b.y) / (b.x - a.x));
    }

    function pointOnCircle(center, radius, angle) {
        const dx = Math.sin(angle) * radius;
        const dy = Math.cos(angle) * radius;
        return center.add(new Point(dx, dy));
    }

    function drawLED(ctx, point, index) {

        // Draw the LED
        ctx.beginPath();
        ctx.arc(point.x, point.y, 1, 0, 2 * Math.PI);
        ctx.stroke();
        if (currentFrame.isOn(index)) {
            ctx.fill();
        }
        ctx.fillText(`D${index}`, point.x + 1.5, point.y);
        // ctx.fillText(`(${ point.x.toFixed(1) }, ${ (100 - point.y).toFixed(1) })`, point.x + 1, point.y);

        // Add the LED to the point map
        ledPositions[index] = point;
    }

    function getMouse(e) {
        let element = canvas, offsetX = 0, offsetY = 0;

        // Compute the total offset
        if (element.offsetParent !== undefined) {
            do {
                offsetX += element.offsetLeft;
                offsetY += element.offsetTop;
            } while ((element = element.offsetParent));
        }

         return new Point((e.pageX - offsetX) / 4, (e.pageY - offsetY) / 4);
    }

    const center = new Point(50, 50);

    function draw() {

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const indexOrder = [
            27, 23, 10, 5, 46, 37,
            28, 24, 11, 4, 47, 38,
            30, 25, 12, 3, 48, 39,
            33, 13, 17, 2, 51, 42,
            34, 14, 18, 1, 52, 43,
            35, 31, 20, 26, 19, 15, 8, 6, 53, 49, 44, 40,
            36, 32, 21, 29, 22, 16, 9, 7, 54, 50, 45, 41,
        ];

        for (let radius = 9; radius <= 50; radius += 9) {
            for (let i = 0; i < 6; i++) {
                const angle = 2 * i * Math.PI / 6;
                const point = pointOnCircle(center, radius, angle);
                drawLED(ctx, point, indexOrder.shift());
            }
        }

        const radius1 = 35;
        const radius2 = 42;

        for (let i = 0; i < 6; i++) {
            const angle = 2 * i * Math.PI / 6;
            const point1 = pointOnCircle(center, radius1, angle - 0.2);
            const point2 = pointOnCircle(center, radius1, angle + 0.2);
            drawLED(ctx, point1, indexOrder.shift());
            drawLED(ctx, point2, indexOrder.shift());
            // const point3 = pointOnCircle(center, radius2, angle - 0.35);
            // const point4 = pointOnCircle(center, radius2, angle + 0.35);
            // ctx.fillText(`(${ radToDeg(anglePoints(point1, point3)).toFixed(1) })`, point3.x + 1, point3.y);
            // ctx.fillText(`(${ radToDeg(anglePoints(point2, point4)).toFixed(1) })`, point4.x + 1, point4.y);
        }

        for (let i = 0; i < 6; i++) {
            const angle = 2 * i * Math.PI / 6;
            const point1 = pointOnCircle(center, radius2, angle - 0.35);
            const point2 = pointOnCircle(center, radius2, angle + 0.35);
            drawLED(ctx, point1, indexOrder.shift());
            drawLED(ctx, point2, indexOrder.shift());
        }

        // Draw the selection box if it is defined
        if (mouseStart && mouseEnd) {
            ctx.beginPath();
            ctx.setLineDash([1,1]);
            const size = mouseEnd.sub(mouseStart);
            ctx.rect(mouseStart.x, mouseStart.y, size.x, size.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

    }

    // Fixes a problem where double clicking causes text to get selected on the canvas
    canvas.addEventListener('selectstart', function(e) { e.preventDefault(); return false; }, false);

    canvas.addEventListener('mousedown', function(e) {

        // Keep track of the initial mouse position
        mouseStart = getMouse(e);

    }, true);

    canvas.addEventListener('mousemove', function(e) {

        // Do nothing if there isn't an initial mouse position
        if (mouseStart){

            // Keep track of the mouse position
            mouseEnd = getMouse(e);

            // Redraw the canvas
            draw();

        }

    }, true);

    canvas.addEventListener('mouseup', function(e) {

        // Check if there was any mouse movement
        if (!mouseEnd) {

            // Toggle all LEDs within range of the mouse
            for (const [index, point] of Object.entries(ledPositions)) {
                if (point.distSquared(mouseStart) < 16) {
                    currentFrame.toggle(index);
                }
            }

        } else {

            // Toggle all LEDs within bounding box
            for (const [index, point] of Object.entries(ledPositions)) {
                if (point.insideRect(mouseStart, mouseEnd)) {
                    currentFrame.toggle(index);
                }
            }

        }

        // Reset the mouse tracking
        mouseStart = mouseEnd = null;

        // Redraw the canvas
        draw();

    }, true);

    // Switch to the given frame and update UI
    function goToFrame(frame) {
        currentFrame = frame;
        draw();
        updateFrameControls();
        updateFrameNavigation();
    }

    // Effect controls
    const importJsonInput = document.querySelector("#effect-controls #import-json");
    const exportJsonButton = document.querySelector("#effect-controls #export-json");

    // Import JSON control
    importJsonInput.addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) {
            return;
        }
        const reader = new FileReader();
        reader.onload = e => {
            const contents = JSON.parse(e.target.result);
            contents.forEach(frame => frame.__proto__ = Frame.prototype);
            frames = contents;
            goToFrame(frames[0]);
        };
        reader.readAsText(file);
    });

    // Export JSON control
    exportJsonButton.addEventListener("click", () => {
        download("effect.json", JSON.stringify(frames));
    });

    // Get frame control elements
    const durationField = document.querySelector("#frame-controls #duration");
    const moveLeftButton = document.querySelector("#frame-controls #move-left");
    const moveRightButton = document.querySelector("#frame-controls #move-right");
    const selectNoneButton = document.querySelector("#frame-controls #select-none");
    const toggleAllButton = document.querySelector("#frame-controls #toggle-all");
    const selectAllButton = document.querySelector("#frame-controls #select-all");
    const copyFrameButton = document.querySelector("#frame-controls #frame-copy");
    const deleteFrameButton = document.querySelector("#frame-controls #frame-delete");

    // Duration control
    durationField.addEventListener("change", e => {
        const val = parseInt(e.target.value);
        if (isNaN(val)) {
            alert("Duration must be a numeric value!");
            durationField.value = currentFrame.duration;
        } else {
            currentFrame.duration = parseInt(e.target.value);
        }
    });

    // Move frame controls
    moveLeftButton.addEventListener("click", () => {
        const oldIndex = frames.indexOf(currentFrame);
        const newIndex = Math.max(oldIndex - 1, 0);
        frames.splice(oldIndex, 1);
        frames.splice(newIndex, 0, currentFrame);
        updateFrameNavigation();
    });
    moveRightButton.addEventListener("click", () => {
        const oldIndex = frames.indexOf(currentFrame);
        const newIndex = Math.min(oldIndex + 1, frames.length);
        frames.splice(oldIndex, 1);
        frames.splice(newIndex, 0, currentFrame);
        updateFrameNavigation();
    });

    // Select all controls
    selectNoneButton.addEventListener("click", () => {
        currentFrame.clearAll();
        draw();
    });
    toggleAllButton.addEventListener("click", () => {
        currentFrame.toggleAll();
        draw();
    });
    selectAllButton.addEventListener("click", () => {
        currentFrame.setAll();
        draw();
    });

    // Duplicate frame control
    copyFrameButton.addEventListener("click", () => {
        const frame = currentFrame.clone();
        frames.splice(frames.indexOf(currentFrame) + 1, 0, frame);
        goToFrame(frame);
    });

    // Delete frame control
    deleteFrameButton.addEventListener("click", () => {
        if (frames.length <= 1) frames.push(new Frame());
        const index = frames.indexOf(currentFrame);
        frames.splice(index, 1);
        goToFrame(frames[Math.max(index - 1, 0)]);
    });

    // Update the frame controls UI
    function updateFrameControls() {
        durationField.value = currentFrame.duration;
    }

    // Get the frame navigation elements
    const frameNav = document.querySelector("#frame-nav ul");
    const playButton = frameNav.querySelector(".play button");
    const addButton = frameNav.querySelector(".add button");

    // Playback controls
    let playbackTimeout = null;
    playButton.addEventListener("click", () => {
        // Check if playback is running
        if (!playbackTimeout) {
            const next = () => {
                goToFrame(frames[(frames.indexOf(currentFrame) + 1) % frames.length]);
                playbackTimeout = setTimeout(next, currentFrame.duration);
            }
            playbackTimeout = setTimeout(next, currentFrame.duration);
            playButton.classList.remove("bi-play");
            playButton.classList.add("bi-stop");
        } else {
            clearTimeout(playbackTimeout);
            playbackTimeout = null;
            playButton.classList.remove("bi-stop");
            playButton.classList.add("bi-play");
        }
    });

    // Add frame control
    addButton.addEventListener("click", () => {
        const frame = new Frame();
        frames.splice(frames.indexOf(currentFrame) + 1, 0, frame);
        goToFrame(frame);
    });

    // Update the frame navigation UI
    function updateFrameNavigation() {

        // Clear all frame elements from the pagination controls
        for (const element of frameNav.querySelectorAll(".frame")) {
            element.remove();
        }

        // Create new frame elements
        for (let i = 0; i < frames.length; i++) {
            const button = document.createElement("button");
            button.classList.add("page-link");
            button.innerText = i + 1;
            button.addEventListener("click", () => goToFrame(frames[i]));
            const li = document.createElement("li");
            li.classList.add("page-item", "frame");
            if (frames[i] === currentFrame) {
                li.classList.add("active");
            }
            li.appendChild(button);
            frameNav.insertBefore(li, addButton.parentNode);
        }

    }

    // Download helper function
    function download(filename, text) {
        const element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    // Initialize the UI
    goToFrame(currentFrame);

</script>

</body>
</html>